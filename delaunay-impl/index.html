<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4.1 - 3D Delaunay Triangulation · AlphaStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/AlphaStructures.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="AlphaStructures.jl logo"/></a><h1>AlphaStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">1 - Home</a></li><li><a class="toctext" href="../gettingStarted/">2 - Getting Started</a></li><li><span class="toctext">Theory...</span><ul><li><a class="toctext" href="../theory-index/">3.0 - Theory Index</a></li><li><a class="toctext" href="../delaunay/">3.1 - Delaunay Triangulation</a></li><li><a class="toctext" href="../voronoy/">3.2 - Voronoy Diagrams</a></li><li><a class="toctext" href="../alpha-structures/">3.3 - Alpha Structures</a></li><li><a class="toctext" href="../persistent-homology/">3.4 - Persistent Homology</a></li></ul></li><li><span class="toctext">... and Practice</span><ul><li><a class="toctext" href="../this-module/">4.0 - Module Introduction</a></li><li class="current"><a class="toctext" href>4.1 - 3D Delaunay Triangulation</a><ul class="internal"><li><a class="toctext" href="#Advantage-1">Advantage</a></li><li><a class="toctext" href="#A-recursive-function-1">A recursive function</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li><li><a class="toctext" href="../alpha-structures-impl/">4.2 - Alpha Structures</a></li><li><a class="toctext" href="../persistent-homology-impl/">4.3 - Persistent Homology</a></li></ul></li><li><a class="toctext" href="../authors/">A - About the Authors</a></li><li><a class="toctext" href="../bibliography/">B - Bibliography</a></li></ul></nav><article id="docs"><header><nav><ul><li>... and Practice</li><li><a href>4.1 - 3D Delaunay Triangulation</a></li></ul><a class="edit-page" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/master/docs/src/delaunay-impl.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4.1 - 3D Delaunay Triangulation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".1-3D-Delaunay-Triangulation-1" href="#.1-3D-Delaunay-Triangulation-1">4.1 - 3D Delaunay Triangulation</a></h1><p>For 3D Delaunay Triangulation of a pointset P <span>$DT(P)$</span>, we use DeWall algorithm of P. Cignoni, C. Montani, R. Scopigno, that can be generalized to <span>$E^d$</span> triangulations.</p><h2><a class="nav-anchor" id="Advantage-1" href="#Advantage-1">Advantage</a></h2><p>The duality between DTs and Voronoi diagrams is well known and therefore algorithms are given for the construction of DT from Voronoi diagrams. However, direct construction methods are generally more efficient because the Voronoi diagram does not need to be computed and stored. The direct DT algorithm that we use is <strong>divide &amp; conquer</strong> (D&amp;C). This is based on the recursive partition and local triangulation of the point set, and then on a merging phase where the resulting triangulations are joined.</p><ul><li>Classic D&amp;C algorithms: recursively subdivide the input dataset, construct the two DTs and then merge them.</li><li>DeWall algorithm: first subdivides the input dataset, then builds that part of the DT that should be built in the merge phase of a classic D&amp;C algorithm and then recursively triangulates the two half–spaces, taking into account the border of the previously computed merge triangulation.</li></ul><h2><a class="nav-anchor" id="A-recursive-function-1" href="#A-recursive-function-1">A recursive function</a></h2><p>The DeWall (Delaunay Wall) algorithm consists of the following steps:</p><ol><li>select a plane π that divides the space into two halfspaces;</li><li>split <span>$P$</span> into two subset <span>$P^-$</span> in the negative halfspace and <span>$P^+$</span> in the positive one;</li><li>construct <span>$S^π$</span>;</li><li>recursively apply DeWall on <span>$P^-$</span>, starting from <span>$S^π$</span>, and build <span>$S^-$</span></li><li>recursively apply DeWall on <span>$P^+$</span>, starting from <span>$S^π$</span>, and build <span>$S^+$</span> (the simplices that are completely contained in the positive halfspace);</li><li>merge <span>$S^π$</span>, <span>$S^-$</span> and <span>$S^+$</span>.</li></ol><p>Where  <span>$S^π = {σ_i: σ_i ∩ π ≠ ∅ }$</span>,  <span>$S^- = {σ_i: σ_i ⊂ NegHalfspace(π)}$</span>,  <span>$S^+ = {σ_i: σ_i ⊂ PosHalfspace(π)}$</span>.</p><h3><a class="nav-anchor" id="Construct-simplex-wall-Sπ-1" href="#Construct-simplex-wall-Sπ-1">Construct simplex wall <span>$S^π$</span></a></h3><p>The simplex wall <span>$S^π$</span> can be simply computed by using an incremental construction approach.</p><p>First of all we need three <strong>active face lists</strong>:</p><ul><li><span>$AFL^π$</span>: the <span>$(d - 1)-faces$</span> intersected by plane;</li><li><span>$AFL^+$</span>: the <span>$(d - 1)-faces$</span> with all of the vertices in <span>$P^+$</span>;</li><li><span>$AFL^-$</span>: the <span>$(d - 1)-faces$</span> with all of the vertices in <span>$P^-$</span>.</li></ul><p>The algorithm starts by constructing an initial <span>$d$</span>-simplex <span>$σ_i$</span> that intersect the plane; then, it processes all of the <span>$(d - 1)-faces$</span> of <span>$σ_i$</span>: the <span>$d$</span>-simplex adjacent to each of them (if it exists, i.e. the face does not belong to the convex hull of <span>$P$</span>) is built and added to the current list of simplices in <span>$DT(P)$</span>. All of the new <span>$(d - 1)-faces$</span> of each new <span>$d$</span>-simplex are used to update the right active face list (AFL).</p><div class="admonition fact"><div class="admonition-title">Fact</div><div class="admonition-text"></div></div><p>For each <span>$(d - 1)-face$</span> <span>$f$</span>, which does not lie on the convex hull of <span>$P$</span>, there are exactly two simplices <span>$σ_1$</span> and <span>$σ_2$</span> in <span>$DT(P)$</span>, such that <span>$σ_1$</span> and <span>$σ_2$</span> share <span>$f$</span>.   So to update the AFL we considered that: if a new face <span>$f$</span> is already contained in AFL, then it is removed from AFL; otherwise, it is inserted in AFL because its adjacent simplex has not yet been built.</p><p>The process continues iteratively:</p><ul><li>extract a face <span>$f$</span> from <span>$AFL^π$</span>,</li><li>build the <span>$d$</span>-simplex <span>$σ$</span> adjacent to <span>$f$</span>,</li><li>update AFLs with the <span>$(d - 1)-face$</span> of <span>$σ$</span>, and then again</li><li>extract another face from <span>$AFL^π$</span> until is empty.</li></ul><h3><a class="nav-anchor" id="A-recursive-call-1" href="#A-recursive-call-1">A recursive call</a></h3><p>Once the simplex wall is computed, DeWall is recursively applied to the pairs (<span>$P^-$</span>, <span>$AFL^-$</span>) and (<span>$P^+$</span>, <span>$AFL^+$</span>), unless all the active face lists are empty. The splitting plane is cyclically selected as a plane orthogonal to the axes of the <span>$E^d$</span> space, in order to recursively partition the space with a regular pattern.</p><h3><a class="nav-anchor" id="The-Pipeline-1" href="#The-Pipeline-1">The Pipeline</a></h3><ol><li>Select the plane π to split <span>$P$</span>;</li><li>Split <span>$P$</span> into two subset <span>$P^-$</span> and <span>$P^+$</span>;</li><li>Construct first simplex of <span>$S^π$</span> with <code>firstDeWallSimplex</code>;</li><li>Construct adjacent simplex to complite <span>$S^π$</span> with <code>findWallSimplex</code>;</li><li>Update all AFLs;</li><li>Construct <span>$S^-$</span> and <span>$S^+$</span>, recursively appling <code>delaunayWall</code> on <span>$P^-$</span> and <span>$P^+$</span>, starting from associated AFL;</li><li>Return the union of <span>$S^π$</span>, <span>$S^-$</span> and <span>$S^+$</span>.</li></ol><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>The input is a set of points in <span>$\mathcal R^d$</span>, of type <code>Lar.Points</code>, the output is a set of <span>$d$</span>-simplices, of type <code>Lar.Cells</code>. So we can create a LAR model to view.</p><h3><a class="nav-anchor" id="D-Delaunay-triangulation-1" href="#D-Delaunay-triangulation-1">3D Delaunay triangulation</a></h3><pre><code class="language-julia">
julia&gt; using AlphaStructures, Plasm

julia&gt; V = [
               0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0
               0.0 0.0 1.0 1.0 0.0 0.0 1.0 1.0
               0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
           ];

julia&gt; DT = AlphaStructures.delaunayWall(V)
6-element Array{Array{Int64,1},1}:
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 4, 5, 6]
 [3, 4, 5, 7]
 [4, 5, 6, 7]
 [4, 6, 7, 8]

julia&gt; Plasm.viewexploded(V,DT)(1.2,1.2,1.2);
</code></pre><h3><a class="nav-anchor" id="D-Delaunay-triangulation-2" href="#D-Delaunay-triangulation-2">2D Delaunay triangulation</a></h3><pre><code class="language-julia">
julia&gt; using AlphaStructures, Plasm

julia&gt; V = [
            0.0 2.0 0.0 4.0 5.0 ;
            0.0 0.0 3.0 1.0 5.0
            ];

julia&gt; DT = AlphaStructures.delaunayWall(V)
3-element Array{Array{Int64,1},1}:
 [2, 3, 4]
 [3, 4, 5]
 [1, 2, 3]

julia&gt; Plasm.viewexploded(V,DT)(1.2,1.2);
</code></pre><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><p><code>@docs  AlphaStructures.firstDeWallSimplex</code>  <code>@docs  AlphaStructures.findWallSimplex</code>  <code>@docs  AlphaStructures.delaunayWall</code></p><footer><hr/><a class="previous" href="../this-module/"><span class="direction">Previous</span><span class="title">4.0 - Module Introduction</span></a><a class="next" href="../alpha-structures-impl/"><span class="direction">Next</span><span class="title">4.2 - Alpha Structures</span></a></footer></article></body></html>
