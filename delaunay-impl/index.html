<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4.1 - DeWall Algorithm · AlphaStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/AlphaStructures.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="AlphaStructures.jl logo"/></a><h1>AlphaStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">1 - Home</a></li><li><a class="toctext" href="../gettingStarted/">2 - Getting Started</a></li><li><span class="toctext">Theory...</span><ul><li><a class="toctext" href="../theory-index/">3.0 - Theory Index</a></li><li><a class="toctext" href="../delaunay/">3.1 - Delaunay Triangulation</a></li><li><a class="toctext" href="../voronoi/">3.2 - Voronoi Diagrams</a></li><li><a class="toctext" href="../alpha-structures/">3.3 - Alpha Structures</a></li><li><a class="toctext" href="../persistent-homology/">3.4 - Persistent Homology</a></li></ul></li><li><span class="toctext">... and Practice</span><ul><li><a class="toctext" href="../this-module/">4.0 - Module Introduction</a></li><li class="current"><a class="toctext" href>4.1 - DeWall Algorithm</a><ul class="internal"><li><a class="toctext" href="#Advantage-1">Advantage</a></li><li><a class="toctext" href="#Delauany-Wall-Pipeline-1">Delauany Wall Pipeline</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li><li><a class="toctext" href="../alpha-structures-impl/">4.2 - Alpha Structures</a></li><li><a class="toctext" href="../persistent-homology-impl/">4.3 - Persistent Homology</a></li></ul></li><li><a class="toctext" href="../authors/">A - About the Authors</a></li><li><a class="toctext" href="../bibliography/">B - Bibliography</a></li></ul></nav><article id="docs"><header><nav><ul><li>... and Practice</li><li><a href>4.1 - DeWall Algorithm</a></li></ul><a class="edit-page" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/master/docs/src/delaunay-impl.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4.1 - DeWall Algorithm</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".1-Delaunay-Wall-Triangulation-Algorithm-1" href="#.1-Delaunay-Wall-Triangulation-Algorithm-1">4.1 - Delaunay Wall Triangulation Algorithm</a></h1><p>We approached the problem as described in [CMS97] and [CMS98].</p><h2><a class="nav-anchor" id="Advantage-1" href="#Advantage-1">Advantage</a></h2><p>The duality between Delaunay Triangulations and Voronoi diagrams has been discussed in <a href="https://eonofri04.github.io/AlphaStructures.jl/delaunay/">section 3.1</a> and <a href="https://eonofri04.github.io/AlphaStructures.jl/voronoy/">section 3.2</a>. However, direct construction methods are generally more efficient because the Voronoi diagram does not need to be computed and stored. Various approaches have been historically used:</p><ul><li>Local improvement: starting with an arbitrary triangulation these algorithms locally modify the faces of pairs of adjacent simplices according to the circumsphere criterion.</li><li>On line (or incremental insertion): starting with a simplex which contains the convex hull of the point set these algorithms insert the points in <code>P</code> one at a time. The simplex containing the currently added point is partitioned by inserting it as a new vertex. The circumsphere criterion is tested on all the simplices adjacent to the new ones recursively and, if necessary, their faces are flipped.</li><li>Incremental construction: the DT is constructed by successively building simplices whose circumhyperspheres contain no points in <code>P</code>.</li><li>Higher dimensional embedding: these algorithms transform the points into the <span>$E^{d+1}$</span> space and then compute the convex hull of the transformed points the DT is obtained by simply projecting the convex hull into <span>$E^{d}$</span>.</li><li>Classic D&amp;C algorithms: this is based on the recursive partition and local triangulation of the point set and then on a merging phase where the resulting triangulations are joined.</li></ul><p>The algorithm we have choosen to encode is one of the latter class. Its peculiarity is that the computational phase is located in the Divide Step (instead of the merge step). Delaunay Wall algorithm first subdivides the input dataset, then builds that part of the DT that should be built in the merge phase of a classic D&amp;C algorithm and then recursively triangulates the two half–spaces, taking into account the border of the previously computed merge triangulation.</p><h2><a class="nav-anchor" id="Delauany-Wall-Pipeline-1" href="#Delauany-Wall-Pipeline-1">Delauany Wall Pipeline</a></h2><p>The DeWall (Delaunay Wall) algorithm could be summed up by following pipeline:</p><ol><li>select a hyperplane <span>$\alpha$</span> that divides the space into two halfspaces</li><li>split the sites <span>$S$</span> into two subset: <span>$S^-$</span> and <span>$S^+$</span> (the points in the negative and positive halfspace)</li><li>construct the <em>Wall</em> (<span>$\Sigma^\alpha$</span>) of the Delaunay simplices over that intersect the plane <span>$\alpha$</span></li><li>recursively apply DeWall on <span>$S^-$</span> to obtain <span>$\Sigma^-$</span></li><li>recursively apply DeWall on <span>$S^+$</span> ro obtain <span>$\Sigma^+$</span></li><li>merge <span>$\Sigma^\alpha$</span>, <span>$\Sigma^-$</span> and <span>$\Sigma^+$</span>.</li></ol><p>In particular we have that:</p><div>\[	\Sigma^\alpha = \{\sigma \in \mathcal D_S \mid \sigma \cap \alpha \ne \emptyset \}\]</div><div>\[	\Sigma^- = \{\sigma \in \mathcal D_S \mid \sigma \in \mbox{NegHalfspace}(\alpha)\}\]</div><div>\[	\Sigma^+ = \{\sigma \in \mathcal D_S \mid \sigma \in \mbox{PosHalfspace}(\alpha)\}\]</div><p>and therefore by construction we have that <span>$\Sigma^\alpha$</span>, <span>$\Sigma^-$</span> and <span>$\Sigma^+$</span> are disjoint and</p><div>\[	\Sigma^\alpha \cup \Sigma^- \cup \Sigma^+ = \mathcal D_S\]</div><h3><a class="nav-anchor" id="Construct-simplex-wall-S\\alpha-1" href="#Construct-simplex-wall-S\\alpha-1">Construct simplex wall <span>$S^\alpha$</span></a></h3><p>The simplex wall <span>$\Sigma^\alpha$</span> can be simply computed by using an incremental construction approach.</p><p>First of all we define three <strong>active face lists</strong>:</p><ul><li><span>$AFL^\alpha$</span>: the <span>$(d - 1)$</span>-simplices intersecting <span>$\alpha$</span></li><li><span>$AFL^+$</span>: the <span>$(d - 1)$</span>-simplices totally located in the negative halfspace defined by <span>$\alpha$</span></li><li><span>$AFL^-$</span>: the <span>$(d - 1)$</span>-simplices totally located in the positive halfspace defined by <span>$\alpha$</span></li></ul><p>The algorithm starts by constructing an initial <span>$d$</span>-simplex <span>$\sigma_0$</span> that intersect the hyperplane (if no active faces are provided). Then, it processes all of the <span>$(d - 1)$</span>-simplices of <span>$σ_0$</span> by splitting them into the Active Face Lists. From now on the <span>$AFL^\alpha$</span> is progressively emptied (and filled) by taking one at time the simplices in it.</p><p>For each <span>$d-1$</span>-simplex <span>$\eta$</span> (wich will belongs to a <span>$d$</span>-simplex <span>$\sigma^1 \in \mathcal D_S$</span>) the algorithm finds out the only other <span>$d$</span>-simplex <span>$\sigma^2$</span> (if it exists) incident on <span>$\eta$</span>: to do so the algorithm looks for the closest point (according to circumradius distance) to the face that do not belongs to the halfspace where the simplex <span>$\sigma^1$</span> is. Lastly all of the new <span>$(d - 1)$</span>-simplex of <span>$\sigma^2$</span> are splitted between the Active Face Lists (do not that in this procedure, if a face is already present in the AFL than it is simply removed since the two simplices incident over it have been found).</p><div class="admonition fact"><div class="admonition-title">Fact</div><div class="admonition-text"><p>For each <span>$(d - 1)$</span>-simplex <span>$\eta$</span>, which does not lie on the convex hull of <span>$S$</span>, there are exactly two simplices <span>$\sigma^1$</span> and <span>$\sigma^2$</span> in <span>$\mathcal D_S$</span>, such that <span>$\sigma^1 \cap \sigma^2 = f$</span>. If the algorithm is not able to find out a second simplex incident on <span>$\eta$</span> we can therefore claim that that simplex belongs to the convex hull of <span>$S$</span>.</p></div></div><p>When the process is over, the wall has been built. It remains to use the Active Face Lists of the positive and negative halfspaces.</p><h3><a class="nav-anchor" id="Recursively-call-DeWall-1" href="#Recursively-call-DeWall-1">Recursively call DeWall</a></h3><p>The wall building process is then applied again to the two halfspaces defined by <span>$\alpha$</span> by choosing another <span>$\alpha$</span>-hyperplane. However if only the points in the halfspace are given to the new call of the function, a careful look must be given to the new simplex evaluated. In fact it could happen that point that earlier where closer to points in the other halfspace, now are closer to other points in the same halfspace. To avoid this annoying situation (solvable in the merge phase checking if any simplex is intersecting any other) a faster solution is to bring into the recursive step also the points that forms the previous walls and discard the simplices that will be formed with that points (in our code, the <code>blacklist</code>).</p><h3><a class="nav-anchor" id="Merging-the-Delaunay-Triangulations-1" href="#Merging-the-Delaunay-Triangulations-1">Merging the Delaunay Triangulations</a></h3><p>If the trick described in the last paragraph have been applied than no particular operations but the merging must be made at this point. In fact the triangulations will be completely disjoint and their intersection will give us back only <span>$AFL^-$</span> and <span>$AFL^+$</span>.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>The input is a set of points in <span>$\mathcal R^d$</span>, of type <code>Lar.Points</code>, the output is a set of <span>$d$</span>-simplices, of type <code>Lar.Cells</code>. So we can create a LAR model to view.</p><h3><a class="nav-anchor" id="D-Delaunay-triangulation-1" href="#D-Delaunay-triangulation-1">3D Delaunay triangulation</a></h3><pre><code class="language-julia">julia&gt; using AlphaStructures, ViewerGL;

julia&gt; GL = ViewerGL;

julia&gt; V = [
 0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0
 0.0 0.0 1.0 1.0 0.0 0.0 1.0 1.0
 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
];

julia&gt; DT = AlphaStructures.delaunayWall(V)
6-element Array{Array{Int64,1},1}:
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 4, 5, 6]
 [3, 4, 5, 7]
 [4, 5, 6, 7]
 [4, 6, 7, 8]

julia&gt; GL.VIEW([
	GL.GLExplode(
		VS,
		[[σ] for σ in DT],
		1.5, 1.5, 1.5,	# Explode Ratio
		99, 1			# Colors
	)
]);
</code></pre><p><img src="../images/3Ddelaunay.png" alt="3Ddelaunay"/></p><h3><a class="nav-anchor" id="D-Delaunay-triangulation-2" href="#D-Delaunay-triangulation-2">2D Delaunay triangulation</a></h3><pre><code class="language-julia">
julia&gt; using AlphaStructures, ViewerGL;

julia&gt; GL = ViewerGL;

julia&gt; V = [
 0.0 2.0 0.0 4.0 5.0
 0.0 0.0 3.0 1.0 5.0
];

julia&gt; DT = AlphaStructures.delaunayWall(V)
3-element Array{Array{Int64,1},1}:
 [2, 3, 4]
 [3, 4, 5]
 [1, 2, 3]

julia&gt; GL.VIEW([
	GL.GLExplode(
		VS,
		[[σ] for σ in DT],
		1., 1.,	1.	# Explode Ratio
		99, 1		# Colors
	)
]);
</code></pre><p><img src="../images/2Ddelaunay.png" alt="2Ddelaunay"/></p><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><p>The solution we have proposed is located in the <code>alphaFilter</code> function (in <a href="https://github.com/eOnofri04/AlphaStructures.jl/blob/master/src/deWall.jl">this</a> file):</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlphaStructures.delaunayWall" href="#AlphaStructures.delaunayWall"><code>AlphaStructures.delaunayWall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delaunayWall(
	P::Lar.Points, ax = 1, Pblack::Float64[], AFL = Array{Int64,1}[],
	tetraDict = DataStructures.Dict{Array{Int64,1},Array{Float64,1}}();
	DEBUG = false
)::Lar.Cells</code></pre><p>Return the Delaunay Triangulation of sites <code>P</code> via Delaunay Wall algorithm. The optional argument <code>ax</code> specify on wich axis it will build the Wall. The optional argument <code>AFL</code> is used in recursive call. If the keyword argument <code>DEBUG</code> is set to true than all the procedure is shown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; P = [
 0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0
 0.0 0.0 1.0 1.0 0.0 0.0 1.0 1.0
 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
];

julia&gt; DT = AlphaStructures.delaunayWall(P)
6-element Array{Array{Int64,1},1}:
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 4, 5, 6]
 [3, 4, 5, 7]
 [4, 5, 6, 7]
 [4, 6, 7, 8]
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/3c1d20cb88ea235b16c91da3f1e8cc773de27da1/src/deWall.jl#L68-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlphaStructures.findWallSimplex" href="#AlphaStructures.findWallSimplex"><code>AlphaStructures.findWallSimplex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">findWallSimplex(
	P::Lar.Points,
	face::Array{Int64,1}, oppoint::Array{Float64,1},
	blackidx = size(P, 2);
	DEBUG = false
)::Union{Array{Int64,1}, Nothing}</code></pre><p>Returns the simplex &#39;σ&#39; build with <code>face</code> and a point from <code>P[:, 1:blackidx]</code> such that it is in the opposite half plane of <code>oppoint</code>. If such a simplex do not exists it returns <code>nothing</code>. If <code>blackidx</code> is not specified all the points <code>P</code> are treaten as valid. If the keyword argument <code>DEBUG</code> is set to true than all the procedure is shown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; P = [
 0. 1. 0. 0. 2.;
 0. 0. 1. 0. 2.;
 0. 0. 0. 1. 2.
];

julia&gt; newtetra = AlphaStructures.findWallSimplex(P,[2,3,4],[0., 0., 0.])
4-element Array{Int64,1}:
 2
 3
 4
 5
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/3c1d20cb88ea235b16c91da3f1e8cc773de27da1/src/deWall.jl#L176-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlphaStructures.firstDeWallSimplex" href="#AlphaStructures.firstDeWallSimplex"><code>AlphaStructures.firstDeWallSimplex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>firstDeWallSimplex( 		P::Lar.Points, ax::Int64, off::Float64; 		DEBUG = false 	)::Array{Int64,1}</p><p>Returns the indices array of the points in <code>P</code> that form the first thetrahedron built over the Wall if the <code>ax</code> axes with contant term <code>off</code>. If the keyword argument <code>DEBUG</code> is set to true than all the procedure is shown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; V = [
	0.0 1.0 0.0 0.0 2.0
	0.0 0.0 1.0 0.0 2.0
	0.0 0.0 0.0 1.0 2.0
];

julia&gt; firstDeWallSimplex(V, 1, AlphaStructures.findMedian(V,1))
4-element Array{Int64,1}:
 1
 2
 3
 4
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/3c1d20cb88ea235b16c91da3f1e8cc773de27da1/src/deWall.jl#L267-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AlphaStructures.recursiveDelaunayWall" href="#AlphaStructures.recursiveDelaunayWall"><code>AlphaStructures.recursiveDelaunayWall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">recursiveDelaunayWall(
	P::Lar.Points,
	Pblack::Lar.Points,
	tetraDict::DataStructures.Dict{Array{Int64,1},Array{Float64,1}},
	AFL::Array{Array{Int64,1},1},
	ax::Int64,
	off::Float64,
	positive::Bool;
	DEBUG = false
)::Lar.Cells</code></pre><p>Utility function that prepeares the Divide phase for Delaunay Wall. Returns the Delaunay Triangulation for the positve or negative subspace of <code>P</code> (according to <code>positive</code>) determined by the hyperplane with normal <code>ax</code> and constant term <code>off</code>. If the keyword argument <code>DEBUG</code> is set to true than all the procedure is shown.</p></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/3c1d20cb88ea235b16c91da3f1e8cc773de27da1/src/deWall.jl#L348-L365">source</a></section><footer><hr/><a class="previous" href="../this-module/"><span class="direction">Previous</span><span class="title">4.0 - Module Introduction</span></a><a class="next" href="../alpha-structures-impl/"><span class="direction">Next</span><span class="title">4.2 - Alpha Structures</span></a></footer></article></body></html>
